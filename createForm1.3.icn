##############################################################################
#                                                                            #
#   File: createForm.icn                                                     #
#                                                                            #
#   Author: Jonah Schnettler                                                 #
#   Author: Matthew Lane                                                     #
#   Author: Derek Howland                                                    #
#                                                                            #
##############################################################################
#                                                                            #
#   This program generates a form for an HTML file from a                    #
#   json schema file using the unicon language.                              #
#                                                                            #
##############################################################################

import xml
link basename
link options
link json
link io

##############################################################################
##
##   This function creates the usage of the file for easier testing
##   Functionality:
##       ./createForm -s <fname>
##
##############################################################################
procedure usage()
  prog := basename(&progname)
  write("Usage: ", prog, " [options]\n")
  write(prog, " is a unicon utility for generating an html file given a json schema")
  write("Options:")

#We'll imlement this if we start validating data
  #write("\t -f : json filename")
	#Old version
  #write("\t -s : json schema file, default to <fname-noext>.schema.json")
	write("\t -s : json schema file, eg <fname>.schema.json")
  write("\t -h : show this help\n")
  exit(-1)
end

#############################################################@################
##
##   This is the main procedure for testing the form generator.
##
##############################################################################
procedure main(args)
	local prog, fname, opts, ext, json_schema, genfile, genfilename, fmt, d, dt, htag, f, elsubmit

	opts := options(args, "hs:")

  if *opts = 0 then
    usage()

#get the json file name, if it is not provided, error out.
  fname :=  \opts["s"] | usage()

#get the schema file
  fname :=  opts["s"]

#determine the output file name
	ext :=  suffix(fname) # split the .json from the extension
	genfilename := ext[1] || ".html"

	prog := basename(&progname)
	write("Usage: ", prog, "   Date: ", &date)
	write("---Begin test createForm.icn---")

  json_schema := jtou(fname, "f")

  write("Here is the generated html form:")

  fmt := XmlFormatter()
  fmt.set_indent(2)
  d := XmlDocument()

#Set !DOCTYPE to HTML.
  dt := DocType()
  dt.set_name("HTML")
  d.add_child(dt)

#Create tag <html lang = "en">.
  htag := XmlElement()
  htag.set_name("html")
  htag.set_attribute("lang", "en")

#Create tag <head>.
  head := XmlElement()
  head.set_name("head")

#Create tag <title>.
  ti := XmlElement()
  ti.set_name("title")
  if \json_schema["title"] then ti.add_child(json_schema["title"])
  else ti.add_child(genfilename)

#start nesting tags into html.
  head.add_child(ti)
  htag.add_child(head)

#Create tag <body>.
  b := XmlElement()
  b.set_name("body")

#Create tag <form> to pass to createForm.
  f := XmlElement()
  f.set_name("form")

#Function call that passes form.XmlElement() and json_schema data.
  createForm(json_schema, f)

#Add submit button to form.
  elsubmit := XmlElement()
  elsubmit.set_name("input")
  elsubmit.set_attribute("type", "submit")
  elsubmit.set_attribute("value", "Submit")
  f.add_child(elsubmit)

#Add child tags to html document.
  b.add_child(f)
  htag.add_child(b)
  d.add_child(htag)

  writes(fmt.format(d))

  #Write document to a file.
  #Open File Stream, using fname
  genfile := open(genfilename, "w")
  write(genfile, fmt.format(d))
  close(genfile)

  write("---Test Complete---")

end

##############################################################################
##
##   -Start creating form elements by adding <style> code for the form at the
##    beginning of the form section of html.
##
##############################################################################
procedure createForm(x, f)
  local s

 #Create <style> tags.
  s := XmlElement()
  s.set_name("style")
 #Add css code to the style tags.
  s.add_child("div {padding: 10px 10px 10px 10px;}")
  s.add_child("div.solid {border-style: solid; border-width: 2px; background-color: #eea29a;}")
  s.add_child("div.inset {border-style: inset; background-color: #eaece5;}")
  s.add_child("div.outset {border-style: outset;}")
  s.add_child("label.spacing {padding: 5px 5px 5px 5px}")
  #s.add_child(".dropbtn {background-color: #b2b2b2;}")
 #Add css styles to form html.
  f.add_child(s)

  formGen(x, f)

end

##############################################################################
##
##   -Get schema file information for form then pass data elements to recursion
##   to be parsed.
##
##############################################################################
procedure formGen(x, f, xparent)
  local div, border, elbreak, elEm

  div := XmlElement()
  div.set_name("div")
  div.set_attribute("class", "inset")

  elEm := XmlElement()
  elEm.set_name("em")

  if \x["$schema"] then {
    #Do we need to do something with this?
    }
  if \x["$id"] then {
    #And what about this?
    }
  if \x["title"] then {
    elTitle := XmlElement()
    elTitle.set_name("h3")
    elTitle.set_attribute("for", "title")
    elTitle.add_child(image(x["title"]))
    div.add_child(elTitle)
    }
  if \xparent then {
    elParent := XmlElement()
    elParent.set_name("label")
    elParent.set_attribute("class", "spacing")
    elParent.set_attribute("for", xparent)
    elParent.add_child(image(xparent))
    div.add_child(elParent)
    }
  if \x["description"] then {
    eldesc := XmlElement()
    eldesc.set_name("label")
    eldesc.set_attribute("class", "spacing")
    eldesc.set_attribute("for", "description")
    elEm.add_child(image(x["description"]))
    eldesc.add_child(elEm)
    div.add_child(eldesc)
    }

  genForm(x, div, xparent)

  f.add_child(div)

end


##############################################################################
##
##   -Begin generating form from schema file.
##   Functionality: genFor(schema_data = x, form element = f, parent of x = xparent)
##
##############################################################################
procedure genForm(x, f, xparent)
  local k, el, elbreak, elinput, div

  div := XmlElement()
  div.set_name("div")
  div.set_attribute("class", "solid")

  el := XmlElement()
  #eldesc := XmlElement()
  #emph := XmlElement()
  #emph.set_name("em")

  #input element
  elinput := XmlElement()
  #<br />
  elbreak := XmlElement()
  elbreak.set_name("br")
######################################################################
#   Begin looping through schema contents.
######################################################################
  every k := key(x) do
    case k of {
      "type": {
        case x["type"] of {
          "object": {
            y := x["properties"]

            every k := key(y) do {
			         formGen(y[k], f, k)
               }
            }
#######################################################
# "type" : "array"
#######################################################
          "array": {
            y := x["items"]

            if \y["enum"] then {
              el.set_name("select")
              el.set_attribute("name", xparent)
              z := y["enum"]
              every k := key(z) do {
                opt := XmlElement()
                opt.set_name("option")
                opt.set_attribute("value", k)
                opt.add_child(image(z[k]))
                el.add_child(opt)
                }
              f.add_child(el)
              }
            else {

              every k := key(y) do {
                #Generate Input Element
			           elinput.set_name("input")

                #Check for input type
				         if \y["type"] then {
						       if (y["type"]=="integer") || (y["type"]=="number") then {
							         elinput.set_attribute("type", "number")
						           }
					         }
					       else {
						       elinput.set_attribute("type", "text")
					         }

                 if \xparent then {
				           elinput.set_attribute("id", xparent)
					         }
					       else elinput.set_attribute("id", "string")

                #Set name to array[]
			           if \x[k] then elinput.set_attribute("name", x[k]||"\[\]")
			           else elinput.set_attribute("name", "array[]")

                #Add <br/>
			           f.add_child(elbreak)

                #Add Input Element
			           f.add_child(elinput)

                #If there are minItems
			           if \x["minItems"] then {
				           elminItems := XmlElement()
                   elminItems.set_name("label")
                   elminItems.set_attribute("for", "minItems")
				           elminItems.add_child(" minItems: "||x["minItems"])
                   f.add_child(elminItems)

                   if x["minItems"] > 1 then {
					            count := x["minItems"]
					            while count > 1 do {
						             elminItemsnum := XmlElement()
						             elminItemsnum.set_name("label")
						             elminItemsnum.set_attribute("for", "minItems")
						             count := count-1
						             f.add_child(elminItemsnum)

                        #Generate Input Element
						             elminItemsnuminput := XmlElement()
						             elminItemsnuminput.set_name("input")

                        #Check for input type
						             if y["type"]=="integer"|| y["type"]=="number" then {
							              elminItemsnuminput.set_attribute("type", "number")
						                }
						             else {
							              elminItemsnuminput.set_attribute("type", "text")
						                }

						             if \xparent then {
							              elminItemsnuminput.set_attribute("id", xparent)
						                }
						             else elminItemsnuminput.set_attribute("id", "string")

						            #Set name to array[]
						             elminItemsnuminput.set_attribute("name", x[k]||"\[\]")

						            #Add <br/>
						             f.add_child(elbreak)

						            #Add Input Element
						             f.add_child(elminItemsnuminput)
                         }
				              }
			             }
			            #If there are uniqueItems
			             if \x["uniqueItems"] then {
				              eluniqueItems := XmlElement()
                      eluniqueItems.set_name("label")
                      eluniqueItems.set_attribute("for", "uniqueItems")
				              eluniqueItems.add_child(" uniqueItems: "||x["uniqueItems"])
                      f.add_child(eluniqueItems)
			                }
                  #Add <br/>
			             f.add_child(elbreak)
                   }
                 }
              }
#######################################################
# "type" : "integer" or "number"
#######################################################
        "integer"|"number": {
          if \x["enum"] then {
            el.set_name("select")
            el.set_attribute("name", xparent)
            y := x["enum"]
            every k := key(y) do {
              opt := XmlElement()
              opt.set_name("option")
              opt.set_attribute("value", k)
              opt.add_child(image(y[k]))
              el.add_child(opt)
              }
            f.add_child(el)
            }
          else {
           #Generate Input Element
			       elinput.set_name("input")
			       elinput.set_attribute("type", "number")

             if \xparent
			       then {
				        elinput.set_attribute("id", xparent)
				        }
			       else {
				        einput.set_attribute("id", "number")
				        }

             if \xparent
			       then {
				        elinput.set_attribute("name", xparent)
				        }
			       else {
				        elinput.set_attribute("name", x[k])
				        }

			      #Handle Minimum and Exclusive Minimum
             if \x["minimum"] then elinput.set_attribute("min", x["minimum"])
			       if \x["exclusiveMinimum"] then elinput.set_attribute("min", x["exclusiveMinimum"])

            #Handle Maximum and Exclusive Maximum
			       if \x["maximum"] then elinput.set_attribute("max", x["maximum"])
             if \x["exclusiveMaximum"] then elinput.set_attribute("max", x["exclusiveMaximum"])

            #Add <br/>
			       f.add_child(elbreak)

            #Add Input Element
			       f.add_child(elinput)

            #Add <br/>
			       f.add_child(elbreak)
             }
          }
#######################################################
# "type" : "string"
#######################################################
          "string": {
            if \x["enum"] then {
              el.set_name("select")
              el.set_attribute("name", xparent)
              y := x["enum"]
              every k := key(y) do {
                opt := XmlElement()
                opt.set_name("option")
                opt.set_attribute("value", k)
                opt.add_child(image(y[k]))
                el.add_child(opt)
                }
              f.add_child(el)
              }
            else {
              #Generate Input Element
			         elinput.set_name("input")
			         elinput.set_attribute("type", "text")

               if \xparent then {
				        elinput.set_attribute("id", xparent)
				        }
			         else elinput.set_attribute("id", "string")

               if \xparent then {
				        elinput.set_attribute("name", xparent)
				        }
			         else elinput.set_attribute("name", x[k])

              #Add <br/>
			         f.add_child(elbreak)

              #Add Input Element
			         f.add_child(elinput)

              #Add <br/>
			         f.add_child(elbreak)
               }
            }
#######################################################
# "type" : "boolean"
#######################################################
        "boolean": {
           #Generate "True" radio button.
            elT := XmlElement()
            elT.set_name("input")
            elT.set_attribute("type", "radio")

            if \xparent then {
              elT.set_attribute("id", xparent)
              }
            else elT.set_attribute("id", "true")
            if \xparent then {
              elT.set_attribute("name", xparent)
              elT.set_attribute("value", "true")
              }
            else {
              elT.set_attribute("name", x[k])
              elT.set_attribute("value", "true")
              }
            #Add <br/>
             f.add_child(elbreak)

            #Add Input Element
             f.add_child(elT)

            el1 := XmlElement()
            el1.set_name("label")
            el1.set_attribute("for", x[k])
            el1.add_child("True")

             f.add_child(el1)

           #Generate "False" radio button.
            elF := XmlElement()
            elF.set_name("input")
            elF.set_attribute("type", "radio")

            if \xparent then {
              elF.set_attribute("id", xparent)
              }
            else elF.set_attribute("id", "false")
            if \xparent then {
              elF.set_attribute("name", xparent)
              elF.set_attribute("value", "false")
              }
            else {
              elF.set_attribute("name", x[k])
              elF.set_attribute("value", "false")
              }

            #Add <br/>
             f.add_child(elbreak)

            #Add Input Element
             f.add_child(elF)

             el2 := XmlElement()
             el2.set_name("label")
             el2.set_attribute("for", x[k])
             el2.add_child("False")

              f.add_child(el2)

            #Add <br/>
             f.add_child(elbreak)
            }
#######################################################
# "type" : default
#######################################################
          default: {
            #el.set_name("label")
            #el.set_attribute("for", k)
            #el.add_child(image(x[k]))
			      #div.add_child(el)
			      ##Add <br/>
			      #div.add_child(elbreak)
            #f.add_child(div)
            }
          }
        }
#########################################################################
# "enum" - this only runs when there is no type for enum values.
#########################################################################
      "enum": {
        if \x["type"] then {}
        else {
          el.set_name("select")
          el.set_attribute("name", xparent)
          y := x["enum"]
          every k := key(y) do {
            opt := XmlElement()
            opt.set_name("option")
            opt.set_attribute("value", k)
            opt.add_child(image(y[k]))
            el.add_child(opt)
            }
            f.add_child(el)
          }
        }
#########################################################################
# "const" : "object"
#########################################################################
      "const": {
        case x["const"] of {
          "object": {
            y := x["properties"]
            every k := key(y) do {
              formGen(y[k], f)
              }
            }
#######################################################
# "const" : "array"
#######################################################
          "array": {
            y := x["items"]
            el.set_name("select")
            el.set_attribute("name", xparent)
            y := x["enum"]
            every k := key(y) do {
              opt := XmlElement()
              opt.set_name("option")
              opt.set_attribute("value", k)
              opt.add_child(image(y[k]))
              el.add_child(opt)
              }
            f.add_child(el)
            }
#######################################################
# "const" : "integer" or "number"
#######################################################
          "integer"|"number": {
            el.set_name("label")
            el.set_attribute("for", image(k))
		        el.add_child(image(x[k]))
            f.add_child(el)
			      #Add <br/>
			      f.add_child(elbreak)
            }
#######################################################
# "const" : "string"
#######################################################
          "string": {
            el.set_name("label")
            el.set_attribute("for", image(k))
            el.add_child(image(x[k]))
            f.add_child(el)
			      #Add <br/>
			      f.add_child(elbreak)
            }
#######################################################
# "const" : default
#######################################################
          default: {
            if \x["const"] then {
              el.set_name("select")
              el.set_attribute("name", xparent)
              y := x["const"]
			        opt := XmlElement()
              opt.set_name("option")
              opt.set_attribute("value", k)
              opt.add_child(image(y))
              el.add_child(opt)
              f.add_child(el)
              }
            }
          }
        }
#########################################################################
# required
#########################################################################
		"required": {
				every k := key(x) do
					y := x["required"]
					requiredel := XmlElement()
					requiredel.set_name("label")
					requiredel.set_attribute("for", "required")
					requiredel.add_child("Required:")
					every g := key(y) do
						requiredel.add_child(y[g])
				div.add_child(requiredel)
				#Add <br/>
				div.add_child(elbreak)
				f.add_child(div)
			  }
#######################################################
# "type" : $ref
#######################################################			
		"$ref": {
			write("\t$ref")
			write("\t\t", x["$ref"])
			#Default case here should be a URL or a link to a def.
			#Nested defs looks like this: "$ref": "#/$defs/veggie" 
			#First handle a url
			#<a href="url">link text</a>
			reflink := XmlElement()
			reflink.set_name("a")
			reflink.set_attribute("href", x["$ref"])
			#div.add_child(reflink)
			#Add <br/>
			#div.add_child(elbreak)
			#f.add_child(div)
		}
#######################################################
# "type" : $defs
#######################################################		
		"$defs": {
			write("\t$defs")
			write("\t\t", image(x["properties"]))
			write(image(x["$defs"]))
			y := x["$defs"]
			every k := key(y) do {
				formGen(y[k], f, k)
            }
		}		
#########################################################################
# default
#########################################################################
      default: {
        #el.set_name("label")
        #el.set_attribute("for", image(k))
        #el.add_child(image(x[k]))
		    #write("jajajaja")
		    #write(k)
		    #div.add_child(el)
		    ##Add <br/>
		    #div.add_child(elbreak)
        #f.add_child(div)
        }
      }
end
